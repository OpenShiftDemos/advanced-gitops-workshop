= ApplicationSets
include::_attributes.adoc[]

In this module, you will learn how to deploy multiple applications from a single Application using the App-of-Apps pattern
and the newer ApplicationSets in Argo CD.

[#app-of-apps]
== App-of-Apps

Before we delve into ApplicationSets, let's dive into the useful link:https://argo-cd.readthedocs.io/en/latest/operator-manual/cluster-bootstrapping/#app-of-apps-pattern[App-of-Apps, window="_blank"]
pattern which predates ApplicationSets.

The concept of App-of-Apps is that you have an Application in Argo CD that points to a location that consists only of Applications. This enables bootstrapping a set of
Applications from a single Application and is useful in use cases such as cluster configuration and same app with multiple environments scenarios.

Before we can deploy the App-of-Apps, we first need to deploy a health check for the Application resource which is not included as a health check in Argo CD at this time.

[NOTE]
This is because in Argo CD 1.x the default Application health check was removed. The author of this workshop link:https://github.com/argoproj/argo-cd/issues/16870[disagrees, window="_blank"] with
that decision but unfortunately this is the current state.

To add the Application Health check, use the following command:

[.console-input]
[source,yaml,subs="attributes",role=execute]
----
oc patch -n {user}-argocd argocd argocd --type=merge --patch-file=/home/lab-user/workshop/content/modules/ROOT/examples/app-of-apps/application-health-patch.yaml
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
argocd.argoproj.io/argocd patched
----

Next, review the applications that the App-of-Apps will be deploying:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
ls -l ~/workshop/content/modules/ROOT/examples/app-of-apps/base/
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
total 12
-rw-r--r--. 1 lab-user 1001040000 525 Jul 29 21:54 coolstore-dev.yaml
-rw-r--r--. 1 lab-user 1001040000 527 Jul 29 21:54 coolstore-prod.yaml
-rw-r--r--. 1 lab-user 1001040000 529 Jul 29 21:54 coolstore-stage.yaml
-rw-r--r--. 1 lab-user 1001040000   0 Jul 29 21:54 kustomization.yaml
----

There are three Applications defined, one for each environment, with kustomize being used to manage them. If you look at each
of these Applications, note that each environment is tied to a different kustomize overlay matching the destination. This
provides an opportunity to tweak the manifests for anything specific to an environment. For example, if you look at the overlays
for the `stage` and `prod` environments, we are patching the vertx-gateway deployment to have two replicas instead of the default
one replica defined in the base.

[source,yaml,subs="+macros,attributes+"]
----
include::ROOT:example$coolstore/overlays/prod/kustomization.yaml[]
----

Proceed to deploy the app-of-apps Application:

[.console-input]
[source,yaml,subs="attributes",role=execute]
----
sed "s/%USER%/{user}/" ~/workshop/content/modules/ROOT/examples/app-of-apps/coolstore-app-of-apps.yaml | oc apply -n {user}-argocd -f -
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
application.argoproj.io/coolstore created
----

Go to the Argo CD UI, notice that we have four Applications deployed. These include the `coolstore` App-of-Apps as well as the
three environment specific Applications that were deployed by the `coolstore` App-of-Apps.

image::app-of-apps-tiles.png[]

Click on the `coolstore` tile. Notice that it has three resources that it deployed which were the environment specific Applications.

image::app-of-apps-resources.png[]

Now before we clean-up the Applications have a closer look at the `coolstore` App-of-Apps we deployed:

[source,yaml,subs="attributes+,+macros"]
----
include::ROOT:example$app-of-apps/coolstore-app-of-apps.yaml[]
----

Notice there is a finalizer defined. This is required if you want an Application to delete the resources it deployed as per the link:https://argo-cd.readthedocs.io/en/latest/user-guide/app_deletion/#about-the-deletion-finalizer[documentation, window="_blank"].

[NOTE]
The kustomize section is used to transform the destination for the Application for your specific user. This is only needed
here as all users are using the same repository. Typically, this would not be required.

In this section, we have seen how we can use App-of-Apps to deploy multiple Applications stored in git. However, this list of
Applications is static. What if we want to create Applications dynamically based on external sources? This is where
ApplicationSets come into play.

Delete the Application:

[.console-input]
[source,yaml,subs="attributes",role=execute]
----
oc delete app coolstore -n {user}-argocd
----

Wait for all of the Applications to be removed from the Argo CD UI.

[#appsets]
== ApplicationSets

As we saw previously, there are often situations where you want to deploy or generate multiple versions of the same Application with variations. These variations can be static,
i.e. a basic list of differing elements, or dynamic based on external inputs such as git repositories.

This is where the Argo CD link:https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset[ApplicationSet,window="_blank"] feature, particularly for the dynamic use case,
comes into play. ApplicationSets enables you to generate Application resources using templating. Each ApplicationSet can include one or
more generators that power the creation of Applications. Argo CD currently includes many different generators and enables users to create custom generators via a Plugin architecture.

Some common examples of these link:https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators[generators,window="_blank"] include:

* Using the link:https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-List[List,window="_blank"] generator for generating applications for different environments. We will look at an example of this shortly
* Leveraging the link:https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Git/[git,window="_blank"] generator to create Applications based on the contents of a git repo. We will look at this in Module 4 as a more dynamic way to generate apps for environments.
* Using the link:https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Pull-Request/[Pull Request,window="_blank"] generator to provision new environments on the fly to run automated tests before merging the code.
* Using the link:https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Cluster/[Cluster,window="_blank"] generator to provision an Application across multiple clusters.
* Using the link:https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Matrix[Matrix,window="_blank"]
and link:https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Merge[Merge,window="_blank"] to combine the results from multiple generators.

[#appsets-static]
=== Static Generation with List Generator

First, let's look at a simple example of an Application that uses a List generator to create Applications for different environments
for the `coolstore` Application. This will be a similar use case to what we saw with App-of-Apps but accomplished
with ApplicationSets.

Deploy the ApplicationSet using the following command:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
sed 's/$USER/{user}/' ~/workshop/content/modules/ROOT/examples/applicationsets/coolstore-list-appset.yaml | oc apply -n {user}-argocd -f -
----

Next, have a look at the ApplicationSet that was deployed with this command:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
oc get appset coolstore -o yaml -n {user}-argocd | oc neat
----

[.console-output]
[source,yaml,subs="attributes+,+macros"]
----
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: coolstore-apps
  namespace: {user}-argocd
spec:
  generators:
  - list: <1>
      elements:
      - environment: dev <2>
      - environment: stage
      - environment: prod
  goTemplate: true
  goTemplateOptions:
  - missingkey=error
  template: <3>
    metadata:
      name: coolstore-{{.environment}} <4>
      namespace: {user}-argocd
    spec:
      destination:
        name: in-cluster
        namespace: {user}-{{.environment}}
      project: workshop
      source:
        path: content/modules/ROOT/examples/coolstore/overlays/{{.environment}}
        repoURL: https://github.com/OpenShiftDemos/advanced-gitops-workshop
        targetRevision: HEAD
      syncPolicy:
        automated:
          prune: true
          selfHeal: true
----
<1> We are using the `list` generator which enables us to provide a static list of elements to dynamically
generate applications. Basically it is 1:1 per element
<2> Each element has one value, `environment`, which will be templated into the resulting Application object.
<3> The `template` section is where we define the Application resource that the ApplicationSet will create
<4> Here is an example of referencing the `environment` value to template the name.

Confirm the three Applications, one for each environment, were created:

image::appset-apps-tiles.png[]

When the ApplicationSet generates the Applications, it assumes ownership of them. Validate this with the following:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
oc get app coolstore-dev -o=jsonpath='{.metadata.ownerReferences}' -n {user}-argocd | jq -s .
----

[.console-output]
[source,yaml,subs="attributes+,+macros"]
----
[
  [
    {
      "apiVersion": "argoproj.io/v1alpha1",
      "blockOwnerDeletion": true,
      "controller": true,
      "kind": "ApplicationSet",
      "name": "coolstore",
      "uid": "1cb40de5-09a0-440e-a12e-28941e9c81b1"
    }
  ]
]
----

As we can see, ApplicationSets provide an easy way to generate Application objects statically. Now let's have a look
where they really shine: dynamic generation based on external sources.

[#appsets-dynamic]
=== Dynamic Generation with git Generator

In this example, we will deploy the front-end of the coolstore using an ApplicationSet with the git generator. The
git generator supports two modes: file and directory. In our case, we will leverage the directory mode to
point the generator at a set of kustomize overlays in the repository.

For those not familiar with kustomize, a common pattern when deploying an application with kustomize for multiple
environments is to have a repository that contains a `base` and `overlays` folders. The base folder contains
all of the manifests to be deployed. The `overlays` are used to patch the base to handle any
environment specific differences.

The structure of `base` and `overlays` we will be using in this example is as follows:

* *base*: the common assets that we want to deploy
* *overlays*:
    ** *dev*: specific values that will override the ones in the base for the "dev" environment
    ** *stage*: specific values that will override the ones in the base for the "stage" environment
    ** *prod*: specific values that will override the ones in the base for the "prod" environment

View this structure in the repository that was cloned earlier:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
find ~/workshop/content/modules/ROOT/examples/coolstore-web -print | sort|sed -e 's;[^/]*/;|--;g;s;--|; |;g'
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
| | | | | | | |--coolstore-web
| | | | | | | | |--base
| | | | | | | | | |--kustomization.yaml
| | | | | | | | | |--web-deploy.yaml
| | | | | | | | | |--web-route.yaml
| | | | | | | | | |--web-svc.yaml
| | | | | | | | |--overlays
| | | | | | | | | |--dev
| | | | | | | | | | |--kustomization.yaml
| | | | | | | | | |--prod
| | | | | | | | | | |--kustomization.yaml
| | | | | | | | | |--stage
| | | | | | | | | | |--kustomization.yaml
----

Let's deploy these applications using an ApplicationSet with the git generator. However,
the git generator is somewhat more complex than the previous static list example. So, let's test
it locally first to verify that it works.

Output the ApplicationSet to a file replacing the workshop $USER variable with your user:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
sed 's/$USER/{user}/' ~/workshop/content/modules/ROOT/examples/applicationsets/coolstore-git-appset.yaml > ~/appset.yaml
----

Let's have a quick look at our new ApplicationSet:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
cat ~/appset.yaml
----

[.console-output]
[source,yaml,subs="attributes+,+macros"]
----
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: coolstore-web
  namespace: {user}-argocd
spec:
  goTemplate: true
  goTemplateOptions: ["missingkey=error"]
  generators:
  - git: <1>
      directories:
      - path: content/modules/ROOT/examples/coolstore/overlays/* <2>
      repoURL: https://github.com/OpenShiftDemos/advanced-gitops-workshop <3>
      revision: HEAD
      values:
        user: {user} <4>
  template:
    metadata:
      name: coolstore-web-{{.path.basename}} <5>
      namespace: '{{ .values.user }}-argocd'
    spec:
      destination:
        name: in-cluster
        namespace: '{{ .values.user }}-{{.path.basename}}'
      project: workshop
      source:
        path: '{{.path.path}}' <6>
        repoURL: https://github.com/OpenShiftDemos/advanced-gitops-workshop
        targetRevision: main
        kustomize:
          patches:
            - target:
                kind: Deployment
                name: web
              patch: |-
                - op: replace
                  path: /spec/template/spec/containers/0/env/0/value
                  value: 'gateway-vertx-{{ .values.user }}-{{.path.basename}}' <7>
      syncPolicy:
        automated:
          prune: true
          selfHeal: true
----
<1> We are using the git generator to create an Application for every directory in the target repository and path
<2> The target path. Each sub-directory in this path will be used to create an application. In our case, the `dev` and `prod` overlays
<3> The target repository
<4> Additional values to pass to the template
<5> The basename of the path for which the Application is being generated. Either `dev` or `prod` in this case
<6> The full path in the repo for the current directory
<7> Example of using the passed in value for `{user}`

Next, test the definition by generating the ApplicationSet locally using the `argocd` CLI:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
argocd appset generate ~/appset.yaml
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
NAME                    CLUSTER     NAMESPACE    PROJECT   STATUS  HEALTH  SYNCPOLICY  CONDITIONS  REPO                                                        PATH                                                        TARGET
{user}-argocd/app-dev    in-cluster  {user}-dev    workshop                  Auto-Prune  <none>      https://github.com/OpenShiftDemos/advanced-gitops-workshop  content/modules/ROOT/examples/coolstore-web/overlays/dev    main
{user}-argocd/app-prod   in-cluster  {user}-prod   workshop                  Auto-Prune  <none>      https://github.com/OpenShiftDemos/advanced-gitops-workshop  content/modules/ROOT/examples/coolstore-web/overlays/prod   main
{user}-argocd/app-stage  in-cluster  {user}-stage  workshop                  Auto-Prune  <none>      https://github.com/OpenShiftDemos/advanced-gitops-workshop  content/modules/ROOT/examples/coolstore-web/overlays/stage  main
----

Note that three Applications are being generated. One for each environment.

To see the YAML for each Application, run the following:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
argocd appset generate ~/appset.yaml -o yaml
----

[IMPORTANT]
Using the CLI to generate Applications is very useful when debugging complex ApplicationSets since
you do not have to spend the time deploying it to the cluster and looking at the Status block to
understand what may not be working.

Now that the generation has been verified, go ahead and deploy it:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
sed 's/$USER/{user}/' ~/workshop/content/modules/ROOT/examples/applicationsets/coolstore-git-appset.yaml | oc apply -n {user}-argocd -f -
----

Check that the Applications have been created:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
oc get apps -n {user}-argocd
----

[.console-output]
[source,yaml,subs="attributes+,+macros"]
----
NAME              SYNC STATUS   HEALTH STATUS
coolstore-dev     Synced        Healthy
coolstore-prod    Synced        Healthy
coolstore-stage   Synced        Healthy
web-dev           Synced        Healthy
web-prod          Synced        Healthy
web-stage         Synced        Healthy
----

We can also verify that the applications have been created and are healthy in Argo CD by checking the Application tiles.

image::coolstore-tiles.png[]

Also in OpenShift, check the Topology for `{user}-dev` and click on the Route to view the running Application:

image::coolstore-topology.png[]

The application should appear as follows:

image::coolstore-web.png[]

[#appsets-conclusion]
== Conclusion

In this module, we learned how to deploy multiple Applications quickly and easily using the App-of-Apps pattern
and ApplicationSets. We saw how ApplicationSets can be used to generate Applications dynamically based
on external input.
