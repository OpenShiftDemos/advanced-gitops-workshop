= ApplicationSets
include::_attributes.adoc[]

In this module you will learn how to deploy multiple applications from a single Application using the App-of-Apps pattern
and the newer ApplicationSets in Argo CD.

[#apps-of-apps]
== App-of-Apps

Before we delve into ApplicatioSets, let's dive into the useful link:https://argo-cd.readthedocs.io/en/latest/operator-manual/cluster-bootstrapping/#app-of-apps-pattern[App-of-Apps, window="_blank"] 
pattern which predates ApplicationSets. 

The concept of App-of-Apps is that you have an Application in Argo CD that points to a location that consists only of Applications. This enables bootstrapping a set of 
Applications from a single Application and is useful in use cases such as cluster configuration and multiple environments.

Before we can deploy the App-of-Apps, we first need to deploy a health check for the Application resource which is not included as an included health check in Argo CD at this time. 

[NOTE]
This is because in Argo CD 1.x the default Application health check was removed, the author of this workshop link:https://github.com/argoproj/argo-cd/issues/16870[disagrees, window="_blank"] with
that decision but unfortunately this is the current state.

To add the Application Health check use the following command:

[.console-input]
[source,yaml,subs="attributes",role=execute]
----
oc patch -n {user}-argocd argocd argocd --type=merge --patch-file=/home/lab-user/workshop/content/modules/ROOT/examples/app-of-apps/application-health-patch.yaml
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
argocd.argoproj.io/argocd patched
----

Next review the applications that the App-of-Apps will be deploying:

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
ls -l ~/workshop/content/modules/ROOT/examples/app-of-apps/base/
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
total 12
-rw-r--r--. 1 lab-user 1001040000 525 Jul 29 21:54 coolstore-dev.yaml
-rw-r--r--. 1 lab-user 1001040000 527 Jul 29 21:54 coolstore-prod.yaml
-rw-r--r--. 1 lab-user 1001040000 529 Jul 29 21:54 coolstore-stage.yaml
-rw-r--r--. 1 lab-user 1001040000   0 Jul 29 21:54 kustomization.yaml
----

There are three Applications defined, one for each environment, with kustomize being used to manage them. If you look at each
of these Applications note that each environment is tied to a different kustomize overlay matching the destination. This
provides an opportunity to tweak the manifests for anything specific to an environment. For example, if you look at the overlays
the `stage` and `prod` environments are patching the vertx-gateway deployment to have two replicas.

[source,yaml,subs="+macros,attributes+"]
----
include::ROOT:example$coolstore/overlays/prod/kustomization.yaml[]
----

Proceed to deploy the app-of-apps Application:

[.console-input]
[source,yaml,subs="attributes",role=execute]
----
sed "s/%USER%/{user}/" ~/workshop/content/modules/ROOT/examples/app-of-apps/coolstore-app-of-apps.yaml | oc apply -n {user}-argocd -f -
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
application.argoproj.io/coolstore created
----

Go to the Argo CD UI, notice that we have four Applications deployed. These include the `coolstore` App-of-Apps as well as the
three environment Applications that were deployed by `coolstore`.

image::app-of-apps-tiles.png[]

Click on the `coolstore` tile, notice that it has three resources that it deployed which were the environment Applications.

image::app-of-apps-resources.png[]

Now before we clean-up the Applications have a closer look at the `coolstore` App-of-Apps we deployed:

[source,yaml,subs="attributes+,+macros"]
----
include::ROOT:example$app-of-apps/coolstore-app-of-apps.yaml[]
----

Notice there is a finalizer defined, this is required if you want the Application to delete the resources it deployed when
using the App-of-Apps pattern as per the link:https://argo-cd.readthedocs.io/en/latest/user-guide/app_deletion/#about-the-deletion-finalizer[documentation, window="_blank"].

[NOTE]
The kustomize section is used to transform the destination for the Application for your specific user. This is only needed
here as all users are using the same repository, typically this would not be required.

In this section we have seen how we can use App-of-Apps to deploy multiple Applications stored in git. However this list of 
Applications is static, what if we want to create Applications dynamically based on external sources? This is where
ApplicationSets come into play.

Delete the Application:

[.console-input]
[source,yaml,subs="attributes",role=execute]
----
delete app coolstore -n {user}-argocd
----

Wait for all of the Applications to be removed from the Argo CD UI.

== ApplicationSets

As we saw previously, there are often situations where you want to deploy or generate multiple versions of the same Application with variations. These variations can be static,
i.e. a basic list of differing elements, or dynamic based on external inputs such as git repositories.

This is where the Argo CD link:https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset[ApplicationSet,window="_blank"] feature, particularly for the dynamic use case,
comes into play. ApplicationSets enables you to generate Application resources using templating. Each ApplicationSet can include one or
more generators that power the creation of Applications. Argo CD currently includes many different generators and enables users to create custom generators via a Plugin architecture.

There are a number of link:https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators[generators,window="_blank"] available, some common examples of these generators include:

* Using the link:https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-List[List,window="_blank"] generator for generating applications for different environments. We will look at an example of this shortly
* Leveraging the link:https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Git/[git,window="_blank"] generator to create Applications based on the contents of a git repo, we will look at this in Module 4 as a more dynamic way to generate apps for environments.
* Using the https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Pull-Request/[Pull Request,window="_blank"] generator to provision new environments on the fly to run automated tests before merging the code.
* Using the link:https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Cluster/[Cluster,window="_blank"] generator to provision an Application across multiple clusters.
* Using the link:https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Matrix[Matrix,window="_blank"]
and link:https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Merge[Merge,window="_blank"] to combine the results from multiple generators.

== Static Generation with List Generator

Let's look at a simple example of an Application that uses a List generator to create Applications for different environments
for the `coolstore` Application we deployed earlier. This will be a similar use case to what we saw with App-of-Apps but done
with ApplicationSets.

Deploy the ApplicationSet using the following command:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
sed 's/$USER/{user}/' ~/workshop/content/modules/ROOT/examples/coolstore-gitops-appset.yaml | sed 's/$SUBDOMAIN/{subdomain}/' | oc apply -f - -n {user}-argocd
----

Next have a look at the ApplicationSet that was deployed with this command:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
oc get appset coolstore-apps -o yaml -n {user}-argocd | oc neat
----

[.console-output]
[source,yaml,subs="attributes+,+macros"]
----
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: coolstore-apps
  namespace: {user}-argocd
  finalizers:
    - resources-finalizer.argocd.argoproj.io <1>
spec:
  generators:
  - list: <2>
      elements:
      - environment: dev <3>
      - environment: prod
  goTemplate: true
  goTemplateOptions:
  - missingkey=error
  template: <4>
    metadata:
      name: coolstore-app-{{.environment}} <5>
      namespace: {user}-argocd
    spec:
      destination:
        name: in-cluster
        namespace: {user}-{{.environment}}
      project: {user}
      source:
        path: content/modules/ROOT/files/gitops/module-02
        repoURL: https://gitea-gitea.{subdomain}/{user}/workshop.git
        targetRevision: HEAD
      syncPolicy:
        automated:
          prune: true
          selfHeal: true
----
<1> Argo CD will automatically delete the Applications when the ApplicationSet is deleted. Including a finalizer ensures that the
resources the Application deployed will also be deleted. See more information link:https://argo-cd.readthedocs.io/en/stable/user-guide/app_deletion/#about-the-deletion-finalizer[here,window="_blank"].
<2> We are using the `list` generator which enables us to provide a static list of elements to dynamically
generate applications, basically it is 1:1 per element
<3> Each element has one value, `environment`, which will be templated into the resulting Application object.
<4> The `template` section is where we define the Application resource that the ApplicationSet will create
<5> Here is an example of referencing the `environment` value to template the name.

Note that while we created these Applications earlier, the ApplicationSet will now assume ownership of them, This
can be validated with the following command:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
oc get app coolstore-app-dev -o=jsonpath='{.metadata.ownerReferences}' -n {user}-argocd | jq -s .
----

[.console-output]
[source,yaml,subs="attributes+,+macros"]
----
[
  [
    {
      "apiVersion": "argoproj.io/v1alpha1",
      "blockOwnerDeletion": true,
      "controller": true,
      "kind": "ApplicationSet",
      "name": "coolstore-apps",
      "uid": "1cb40de5-09a0-440e-a12e-28941e9c81b1"
    }
  ]
]
----

As we can see ApplicationSets provide an easy way to generate Application objects statically but now let's have a look
at dynamic generation.

== Dynamic Generation with git Generator

A common pattern when deploying an application to multiple environments is to have a repository that contains the following structure:

* *base*: the common assets that we want to deploy
* *overlays*:
    ** *dev*: specific values that will override the ones in the base for the "dev" environment
    ** *prod*: specific values that will override the ones in the base for the "prod" environment

Let's deploy these applications using an ApplicationSet as we did previously but this time we will use a git generator.

[.console-input]
[source,sh,subs="attributes",role=execute]
----
sed 's/$USER/{user}/' ~/workshop/content/modules/ROOT/examples/web-nodejs-appset.yaml | sed 's/$SUBDOMAIN/{subdomain}/' | oc apply -f - -n {user}-argocd
----

Let's have a quick look at our new ApplicationSet:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
oc get appset web-nodejs -o yaml -n {user}-argocd | oc neat
----

[.console-output]
[source,yaml,subs="attributes+,+macros"]
----
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: web-nodejs
  namespace: {user}-argocd
  finalizers:
    - resources-finalizer.argocd.argoproj.io <1>
spec:
  generators:
  - git: <1>
      directories:
      - path: globex/overlays/* <2>
      repoURL: https://gitea-gitea.{subdomain}/{user}/gitops.git <3>
      revision: HEAD
      values:
        user: {user} <4>
  goTemplate: true
  goTemplateOptions:
  - missingkey=error
  template:
    metadata:
      name: app-{{.path.basename}} <5>
      namespace: '{{ .values.user }}-argocd'
    spec:
      destination:
        name: in-cluster
        namespace: '{{ .values.user }}-{{.path.basename}}'
      project: '{{ .values.user }}'
      source:
        kustomize:
          patches:
          - patch: |-
              - op: replace
                path: /spec/template/spec/containers/0/env/0/value
                value: 'gateway-vertx-{{ .values.user }}-{{.path.basename}}'
            target:
              kind: Deployment
              name: web-nodejs
        path: '{{.path.path}}' <6>
        repoURL: https://gitea-gitea.{subdomain}/{user}/gitops.git
        targetRevision: main
      syncPolicy:
        automated:
          prune: true
----
<1> We are using the git generator to create an Application for every directory in the target repository and path
<2> The target path, each sub-directory in this path will be used to create an application. In our case the `dev` and `prod` overlays
<3> The target repository
<4> Additional values to pass to the template
<5> The basename of the path for which the Application is being generated, either `dev` or `prod` in this case
<6> the full path in the repo for the current directory

Check that the Applications have been created:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
oc get apps -n {user}-argocd
----

[.console-output]
[source,yaml,subs="attributes+,+macros"]
----
app-dev              Synced        Healthy
app-prod             Synced        Progressing
coolstore-app-dev    Synced        Healthy
coolstore-app-prod   Synced        Healthy
dev-tools            Synced        Healthy
pipeline-helm        Synced        Healthy
----

[NOTE]
The `app-prod` application may be `Progressing` for awhile or show as `Degraded`, this is because we have not yet deployed the updated
image generated by the Pipeline in production. We will perform this step in the next section.

We can verify that the applications have been created in the Shared OpenShift GitOps by checking the Application tiles.

* Go to OpenShift GitOps and select the "app-dev" application in the main page to access the details.

* On the top-left side, click on *"App details"* to access the information about the application, such as the git repository, the branch where the files are located, the target cluster and namespace where the application is deployed, etc.

If we pay closer attention, there are 3 items worth mentioning to understand the multi-environment management:

* *REPO_URL:* the git repository where our the resources we want to deploy are defined

* *TARGET REVISION:* the branch to use

* *PATH:* the folder that contains the specific values for that environment. Here for example, for the "DEV" environment, we use the file located in "globex/overlays/dev".

You can see more details by opening the "gitops" repository in gitea, and navigating to "globex" folder.

== Combining Generators
