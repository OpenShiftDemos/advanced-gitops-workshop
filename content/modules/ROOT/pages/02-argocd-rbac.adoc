= Argo CD Role Based Access Control (RBAC)
include::_attributes.adoc[]

=== Introduction

In this module we will review and configure access to the provided Argo CD instance.

Argo CD has it's own Role Based Access Control (RBAC) that is separate and distinct from Kubernetes RBAC. When you interact
with Argo CD via the Argo CD UI, CLI or API the Argo CD RBAC is enforced. If you interact with Argo CD resources directly
using the OpenShift Console or `kubectl`/`oc` then only the Kubernetes RBAC is used.

Additionally the application-controller in Argo CD, as shown previously in the GitOps Architecture, interacts with the
Kubernetes API and is governed by Kubernetes RBAC. Argo CD can only deploy and manage the Kubernetes resources that
the application-controller has been given permission to use in Kubernetes RBAC.

This relationship is shown in the following diagram:

image::argocd-rbac.png[]

The Argo CD RBAC is implemented using the link:https://casbin.org/docs/overview[Casbin, window="_blank"] library. Permissions
are defined by creating roles and then assigning those roles to groups, or individual users, as needed. Argo CD includes
two roles out of the box:

* role:readonly - provides read-only access to all resources
* role:admin - allows unrestricted access to all resources

Roles and permissions can be defined in two places, globally and on a per Project basis. It is strongly recommended that tenant
roles and permissions be defined in the Project and global roles be reserved for Argo CD administrators and managing
globally scoped resources.

=== Test Permissions

Let's confirm we do not have access to deploy Applications at the moment.

image::argocd-new-app.png[]

Next click on the `Edit YAML` button:

image::argocd-create-app.png[]

This will take you to a YAML editor, paste the following Application YAML:

[.console-input]
[source,yaml,subs="attributes",role=execute]
----
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: bgd
  namespace: {user}-argocd
spec:
  destination:
    namespace: {user}-dev
    server: https://kubernetes.default.svc
  source:
    path: bgd/base
    repoURL: https://github.com/gitops-examples/getting-started
    targetRevision: HEAD
  project: default
  syncPolicy:
    automated:
      prune: false
      selfHeal: true
----

Press `Save` to go back to the form view and then press `Create`, notice you receive the following error message:

image::argocd-permission-denied.png[]

What's the issue? Let's start by looking at what groups you are member of, in the Argo CD user interface select the User Info section in the left
sidebar:

image::argocd-groups.png[]

Notice that the only non-system group that you are a member of is `team{usernum}`, check the Global RBAC to see what groups have been
granted permissions:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
 oc get argocd argocd -n {user}-argocd -o=jsonpath="{.spec.rbac}" | yq . -P
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
    defaultPolicy: ""
    policy: |
        g, system:cluster-admins, role:admin
        g, cluster-admins, role:admin
    scopes: '[groups]'
----

By default with OpenShift GitOps the RBAC included in a default instance of Argo CD only grants permissions to a user with cluster-admin permissions and
we are not a member of that group.

We could remediate the problem by defining permissions for the `team{usernum}` group here in the Global RBAC but let's start with a bottom-up
approach by creating a new Argo CD Project with the needed permissions and then circle back to the Global RBAC.

=== Argo CD Projects

Argo CD link:https://argo-cd.readthedocs.io/en/stable/user-guide/projects/[Projects,window='_blank'] are used to group Applications together as well as manage
permissions to the Applications and other Project scoped resources. Keep in mind that an Argo CD Project is different then an OpenShift Project despite using
the same terminology. An OpenShift Project is represented by `kind: Project` in Kubernetes whereas an Argo CD Project is represented by `kind: AppProject`.

While every Application in Argo CD must be associated with a Project, they are particularly useful when managing a multi-tenant Argo CD as the Project not
only determines the user permissions but can also restrict what Applications associated with the Project can do. As per the
link:https://argo-cd.readthedocs.io/en/stable/user-guide/projects[documentation], an Argo CD Project can:

* restrict what may be deployed (trusted Git source repositories)
* restrict where apps may be deployed to (destination clusters and namespaces)
* restrict what kinds of objects may or may not be deployed (e.g. RBAC, CRDs, DaemonSets, NetworkPolicy etc...)
* defining project roles to provide application RBAC (bound to OIDC groups and/or JWT tokens)

[IMPORTANT]
Argo CD includes a `default` project when it is installed, it is strongly recommended that this never be used and administrators create
Projects as needed to support their specific use cases.

Let's see what projects are available in Argo CD:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
oc get appproject -n {user}-argocd
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
NAME      AGE
default   168m
----

As expected, since this is a default Argo CD instance we only have the `default` AppProject. To view the definition of the `default` project
run the following:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
oc get appproject default -n {user}-argocd -o yaml | oc neat
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: default
  namespace: user4-argocd
spec:
  clusterResourceWhitelist:
  - group: '*'
    kind: '*'
  destinations:
  - namespace: '*'
    server: '*'
  sourceRepos:
  - '*'
----

Note the `default` Project has no restrictions associated with it, Applications using this Project can deploy any resource, namespace or cluster
that Argo CD itself has access to. However no permissions have been defined here either which means that unless we have permissions
defined in the Global RBAC, which we already checked, we cannot deploy any Applications with the `default` project.

[NOTE]
Remember that Argo CD only has access to the Kubernetes resources that the `argocd-argocd-application-controller` ServiceAccount has been
given access to in Kubernetes. So even though the Project may not restrict access to everything Argo CD is still potentially restricted
by the Kubernetes permissions it has been granted,

Since we don't want to use the `default` Project, we will create a new Project to deploy Applications

[.console-input]
[source,sh,subs="attributes",role=execute]
----
sed "s/%USERNUM%/{usernum}/" ~/workshop/content/modules/ROOT/examples/rbac/appproject.yaml | sed "s/%USERNUM%\//{usernum}\//" | oc apply -n user{usernum}-argocd -f -
----

Now view the AppProject we just created:
[.console-input]
[source,sh,subs="attributes",role=execute]
----
oc get appproject workshop -n {user}-argocd -o yaml | oc neat
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: workshop
  namespace: {user}-argocd
spec:
  clusterResourceBlacklist: <1>
  - group: '*'
    kind: '*'
  description: Team2's' Project <2>
  destinations: <3>
  - namespace: {user}-dev
    server: https://kubernetes.default.svc
  - namespace: {user}-stage
    server: https://kubernetes.default.svc
  - namespace: {user}-prod
    server: https://kubernetes.default.svc
  namespaceResourceBlacklist: <4>
  - group: ""
    kind: ResourceQuota
  - group: ""
    kind: LimitRange
  - group: operators.coreos.com
    kind: '*'
  - group: operator.openshift.io
    kind: '*'
  - group: storage.k8s.io
    kind: '*'
  roles: <5>
  - description: Team{usernum} Admins
    groups:
    - team2
    name: admin
    policies:
    - p, proj:workshop:admin, applications, *, workshop/*, allow
    - p, proj:workshop:admin, exec, create, workshop/*, allow
  sourceRepos: <6>
  - https://github.com/OpenShiftDemos/advanced-gitops-workshop
  - https://github.com/gitops-examples/getting-started
[.console-output]
[source,bash,subs="attributes+,+macros"]
----

Review the items defined by the `workshop` AppProject:

<1> First all cluster scoped resources, i.e. resources that don't have a namespace such as ClusterRole. This prevents users from deploying cluster level resources
<2> We define a friendly description for the project
<3> The destinations that Applications that belong to this AppProject are permitted to deploy resources. Specifically we permit the `{user}-dev`, `{user}-stage` and `{user}-prod` namespaces in the local cluster Kubernetes server `https://kubernetes.default.svc`. We could wildcard the namespaces with a single destination using `{user}-*`, however we do not want to have `{user}-argocd` as a valid destination.
<4> Certain namespace scoped resources that are typically the purview of the platform team are blacklisted
<5> Project scoped `roles` are defined that provide fine-grained permissions. This will be looked at in more detail shortly
<6> The `sourceRepos` limits which git repositories can be used in Applications.

Let's look at the roles that were defined in the next section.

=== Argo CD Project RBAC

Now let's focus on the RBAC defined in the `workshop` Project that we created:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
 oc get appproject workshop -n {user}-argocd -o=jsonpath="{.spec.roles}" | yq . -P
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
  roles:
  - description: Team2 Admins
    groups:
    - team{usernum} <1>
    name: admin <2>
    policies: <3>
    - p, proj:workshop:admin, applications, *, workshop/*, allow
    - p, proj:workshop:admin, exec, create, workshop/*, allow
----

Here we are defining a single role:

<1> This role is linked to the group `team{usernum}` which your user is a member of.
<2> The name of the role is `admin`, note that this role is scoped to this Project.
<3> The policies, i.e permissions, that are applied by this role.

Let's break down the first policy into it's constituent parts:

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
p   , <1>
proj:workshop:admin, <2>
applications, <3>
* , <4>
workshop/*, <5>
allow <6>
----

<1> The letter `p` indicates that a policy is being defined, this is how we assign
permissions to roles.
<2> Next is the role this policy will be part of. In this case
it is the `admin` role which is scoped to the `workshop` Project.
<3> Then the resource type for which we are giving permissions to, in this case `applications`. Various
Argo CD resource types are supported including `applications`, `clusters`, and
link:https://argo-cd.readthedocs.io/en/stable/operator-manual/rbac/#rbac-resources-and-actions[more, window="_blank"].
<4> After resource we define the actions for the policy, in this case we use a wildcard, '*', to permit all actions. Many
different link:https://argo-cd.readthedocs.io/en/stable/operator-manual/rbac/#rbac-resources-and-actions[actions, window="_blank"]
are available.
<5> Next is the specific Argo CD resource, this can be a wildcard like `*` for all resources or a named resource such as specific Applications. In this case
we have `workshop/*` which allows all Applications that belong to the `workshop` Project.
<6> Finally whether we `allow` or `deny` the permission, in this case we `allow` to grant permissions.

The second policy line with the `exec` permission enables usage of the terminal in the Argo CD user interface.

Now let's try to create Application again using the same steps as previously, it is the same Application yaml as previously
but the project is changed from `default` to `workshop`

[.console-input]
[source,yaml,subs="attributes",role=execute]
----
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: bgd
  namespace: {user}-argocd
spec:
  destination:
    namespace: {user}-dev
    server: https://kubernetes.default.svc
  source:
    path: bgd/base
    repoURL: https://github.com/gitops-examples/getting-started
    targetRevision: HEAD
  project: workshop
  syncPolicy:
    automated:
      prune: false
      selfHeal: true
----





As discussed, the ability to view this basic project has been granted but
not to modify or delete it. To confirm that, try deleting the Project:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
argocd proj delete {user}
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
FATA[0000] rpc error: code = PermissionDenied desc = permission denied: projects, delete, user1, sub: user1-cli, iat: 2024-07-30T17:14:43Z
----

As expected we were denied permission to delete the Project. Again as a reminder the Argo RBAC is only used when you interact with
Argo CD via its UI or CLI. If you have permissions on the `AppProject` kind in the Argo CD namespace you could delete the resource
with `oc delete appproject {user} -n gitops` and the Argo CD RBAC would never be checked,

This inability to let users interact with resources in the Argo CD namespace is a challenge when you want to give users the ability to
declaratively manage Applications instead of managing them imperatively via the UI or CLI, fortunately
Argo CD has you covered as we will see in the next module.

Let's go ahead and deploy an Application and see if we have permissions. Click on the `+New App` button:

image::argocd-new-app.png[]

Next click on the `Edit YAML` button:

image::argocd-create-app.png[]

This will take you to a YAML editor, paste the following Application YAML:

[.console-input]
[source,yaml,subs="attributes",role=execute]
----
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: bgd
  namespace: {user}-argocd
spec:
  destination:
    namespace: {user}-dev
    server: https://kubernetes.default.svc
  source:
    path: bgd/base
    repoURL: https://github.com/gitops-examples/getting-started
    targetRevision: HEAD
  project: default
  syncPolicy:
    automated:
      prune: false
      selfHeal: true
----

Press `Save` to go back to the form view and then press `Create`, notice you receive the following error message:

image::argocd-permission-denied.png[]

What's the issue? Let's start by looking at what groups you are member of, in the Argo CD user interface select the User Info section in the left
sidebar:

image::argocd-groups.png[]

Notice you are not a member of the cluster-admins group, rather you are a member of the `team{usernum}`
group. Since the Argo CD RBAC we looked at earlier does not include this group this means you do not have any access to
the Argo CD instance.






=== Argo CD Global RBAC

The global permissions for Argo CD are defined in the Argo CD Custom Resource (CR) when using the Argo CD Operator. If you are
not using the operator then these global roles are defined in the `argocd-rbac-cm` ConfigMap.

By default with OpenShift GitOps the RBAC included in a default instance of Argo CD only grants permissions to a user with cluster-admin permissions. Run
the following command to see how your Argo CD instance is currently configured with respect to RBAC:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
 oc get argocd argocd -n {user}-argocd -o=jsonpath="{.spec.rbac}" | yq . -P
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
    defaultPolicy: ""
    policy: |
        g, system:cluster-admins, role:admin
        g, cluster-admins, role:admin
    scopes: '[groups]'
----

A few items to note about this global configuration:

* First the `policy.default` is set to an empty string so that users are denied access to resources by default with permissions needing
to be explicitly enabled.
* Next we have the policy section where we define policies and assign them to groups.
** Users in the `system:cluster-admins` group are assigned to the `role:admin` role, this group only applies to the `kube-admin` user.
** The next line operates similarly but grants the `role:admin` role to any users in the cluster-admins group.
* Finally scopes are set to include accounts, groups and email. Argo CD uses OIDC for authentication and this
matches OIDC link:https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims[scopes, window="_blank"], scopes selected
here can be used to match groups in the policy section.

[IMPORTANT]
Any permissions given in the `policy:default` cannot be removed by additional roles using a `deny` permission hence why we
use an empty string so no permissions are granted. The author prefers to explicitly define a `role:none` for this purpose
to avoid ambiguity as will see shortly.

Let's go ahead and deploy an Application and see if we have permissions. Click on the `+New App` button:

image::argocd-new-app.png[]

Next click on the `Edit YAML` button:

image::argocd-create-app.png[]

This will take you to a YAML editor, paste the following Application YAML:

[.console-input]
[source,yaml,subs="attributes",role=execute]
----
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: bgd
  namespace: {user}-argocd
spec:
  destination:
    namespace: {user}-dev
    server: https://kubernetes.default.svc
  source:
    path: bgd/base
    repoURL: https://github.com/gitops-examples/getting-started
    targetRevision: HEAD
  project: default
  syncPolicy:
    automated:
      prune: false
      selfHeal: true
----

Press `Save` to go back to the form view and then press `Create`, notice you receive the following error message:

image::argocd-permission-denied.png[]

What's the issue? Let's start by looking at what groups you are member of, in the Argo CD user interface select the User Info section in the left
sidebar:

image::argocd-groups.png[]

Notice you are not a member of the cluster-admins group, rather you are a member of the `team{usernum}`
group. Since the Argo CD RBAC we looked at earlier does not include this group this means you do not have any access to
the Argo CD instance.

Let's go ahead and change that by giving ourselves `admin` access to the instance. To do this we will add a new group to the RBAC definition
using the following patch:

[source,yaml,subs="+macros,attributes+"]
----
include::ROOT:example$rbac/argocd_rbac_patch.yaml[]
----

[.console-input]
[source,sh,subs="attributes",role=execute]
----
sed "s/%USERNUM%/{usernum}/" ~/workshop/content/modules/ROOT/examples/rbac/argocd_rbac_patch.yaml | kubectl patch -n user{usernum}-argocd argocd argocd --type=merge --patch-file=/dev/stdin
----

Check the results of this patch by executing the previous command to fetch the RBAC:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
oc get argocd argocd -n {user}-argocd -o=jsonpath="{.spec.rbac}" | yq . -P
----

[.console-output]
[source,yaml,subs="attributes+,+macros"]
----
    defaultPolicy: role:none
    policy: |
      p, role:none, *, *, */*, deny
      g, system:cluster-admins, role:admin
      g, team2, role:admin
----

Notice a new group has been added to the policy section granting users in team{usernum} the `admin` role.

We can also define our own policies here, as we can see with the new `role:none` that was added, if we need to define
fine-grained permissions. We will look at the more later when talking about Argo CD Projects and RBAC but first we
need to understand what an Argo CD Project is and why it is needed.

Verify you can deploy the Application by repeating the previous steps, here is the Application file again:

[.console-input]
[source,yaml,subs="attributes",role=execute]
----
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: bgd
  namespace: {user}-argocd
spec:
  destination:
    namespace: {user}-dev
    server: https://kubernetes.default.svc
  source:
    path: bgd/base
    repoURL: https://github.com/gitops-examples/getting-started
    targetRevision: HEAD
  project: default
  syncPolicy:
    automated:
      prune: false
      selfHeal: true
----

Wait for the Application to become Healthy and Synched as follows:

image::argocd-bgd-app.png[]

In the first line of the Application it shows the Application belongs to the `default` project, in the next section we will look at how Projects
are used in Argo CD and why it is important to define them for multi-tenant Argo CD instances.

=== Argo CD Projects

Argo CD link:https://argo-cd.readthedocs.io/en/stable/user-guide/projects/[Projects,window='_blank'] are used to group Applications together as well as manage
permissions to the Applications and other Project scoped resources. Keep in mind that an Argo CD Project is different then an OpenShift Project despite using
the same terminology. An OpenShift Project is represented by `kind: Project` in Kubernetes whereas an Argo CD Project is represented by `kind: AppProject`.

While every Application in Argo CD must be associated with a Project, they are particularly useful when managing a multi-tenant Argo CD as the Project not
only determines the user permissions but can also restrict what Applications associated with the Project can do. As per the
link:https://argo-cd.readthedocs.io/en/stable/user-guide/projects[documentation], an Argo CD Project can:

* restrict what may be deployed (trusted Git source repositories)
* restrict where apps may be deployed to (destination clusters and namespaces)
* restrict what kinds of objects may or may not be deployed (e.g. RBAC, CRDs, DaemonSets, NetworkPolicy etc...)
* defining project roles to provide application RBAC (bound to OIDC groups and/or JWT tokens)

[IMPORTANT]
Argo CD includes a `default` project when it is installed, it is strongly recommended that this never be used and administrators create
Projects as needed to support their specific use cases.

Let's see what projects are available in Argo CD:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
oc get appproject -n {user}-argocd
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
NAME      AGE
default   168m
----

As expected, since this is a default Argo CD instance we only have the `default` AppProject. To view the definition of the `default` project
run the following:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
oc get appproject default -n {user}-argocd -o yaml | oc neat
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: default
  namespace: user4-argocd
spec:
  clusterResourceWhitelist:
  - group: '*'
    kind: '*'
  destinations:
  - namespace: '*'
    server: '*'
  sourceRepos:
  - '*'
----

Note the `default` Project has no restrictions associated with it, Applications using this Project can deploy any resource, namespace or cluster
that Argo CD itself has access to.

[NOTE]
Remember that Argo CD only has access to the Kubernetes resources that the `argocd-argocd-application-controller` ServiceAccount has been
given access to in Kubernetes. So even though the Project may provide access to everything Argo CD is still potentially restricted
by the Kubernetes permissions it has been granted,

Since we don't want to use the `default` Project, we will create a new Project to deploy Applications

In our Shared GitOps instance each workshop team, and thus user, has their own Project to manage access and restrictions for their Applications. To
view your teams project, use the CLI to run the following command:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
argocd proj list
----

Notice that a single project is listed:

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
NAME   DESCRIPTION    DESTINATIONS    SOURCES  CLUSTER-RESOURCE-WHITELIST  NAMESPACE-RESOURCE-BLACKLIST  SIGNATURE-KEYS  ORPHANED-RESOURCES
{user}  {user} project  5 destinations  *        <none>                      <none>                        <none>          disabled
----

A detailed view of the project is retrieved by using the `get` command:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
argocd proj get {user}
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
Name:                        {user}
Description:                 {user} project
Destinations:                .{user}-argocd
                             ,{user}-dev
                             ,{user}-prod
                             ,{user}-cicd
Repositories:                *
Scoped Repositories:         <none>
Allowed Cluster Resources:   <none>
Scoped Clusters:             <none>
Denied Namespaced Resources: /Namespace
                             /ResourceQuota
                             /LimitRange
                             operators.coreos.com/*
                             operator.openshift.io/*
                             storage.k8s.io/*
                             machine.openshift.io/*
                             machineconfiguration.openshift.io/*
                             compliance.openshift.io/*
Signature keys:              <none>
Orphaned Resources:          disabled
----

Notice that your user's Applications are limited to deploying to a specific set of namespaces, the `{user}-*` namespaces.
This limitation on destinations ensures that Applications in this Project cannot deploy resources to other namespaces
even though the underlying Argo CD application-controller has permissions to do so.

Also note that we are denying access to some types of resources. All cluster scoped resources, i.e. resources without a namespace,
are denied. Also note that we are denying access to specific namespace scoped resources such as ResourceQuota and LimitRange because
it is the purview of the platform team to manage these resources.

Finally some Argo CD resources, such as clusters and repositories, can be scoped globally or at a Project level. Scoping resources
at a Project level can be useful in cases where the Argo CD administrator would like to enable self-service
for application teams. In this workshop these resources are defined globally however if you would like to learn
more about this capability the Argo CD documentation covers this topic in depth.

link:https://argo-cd.readthedocs.io/en/stable/user-guide/projects/#project-scoped-repositories-and-clusters[Project scoped Repositories and Clusters,window="_blank"]


Now let's look at the RBAC defined in the Project that has been setup for your team and user:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
argocd proj role list {user}
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
ROLE-NAME  DESCRIPTION
admin      TeamX admins
pipeline   Pipeline accounts
----

This shows that two roles are defined, `admin` and `pipeline`. The `admin` role is intended for
users who will administer Applications in this Project. The `pipeline` role is intended
for automation tools and will be used by OpenShift Pipelines in a later module.

Now look at how the roles are defined:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
argocd proj role get {user} admin
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
Role Name:     admin
Description:   TeamX admins
Policies:
p, proj:{user}:admin, projects, get, {user}, allow
p, proj:{user}:admin, applications, *, {user}/*, allow
p, proj:{user}:admin, exec, create, {user}/*, allow
g, team1, proj:{user}:admin
g, user1-cli, proj:{user}:admin
p, proj:{user}:pipeline, projects, get, {user}, allow
p, proj:{user}:pipeline, applications, get, {user}/*, allow
p, proj:{user}:pipeline, applications, sync, {user}/*, allow
g, {user}-pipeline, proj:{user}:pipeline
----

Here we can see information about the role including policies, let's break
down the first policy into it's constituent parts to understand how it is defined.

image::gitops/argocd-policy.png[]

1. The letter `p` indicates that a policy is being defined, this is how we assign
permissions to roles.
2. Next is the role this policy will be part of. In this case
it is the `admin` role which is scoped to Project `{user}`.
3. Then the resource type for which we are giving permissions to, in this case `projects`. Various
Argo CD resource types are supported including `applications`, `clusters`, and
link:https://argo-cd.readthedocs.io/en/stable/operator-manual/rbac/#rbac-resources-and-actions[more, window="_blank"].
4. After resource we define the actions for the policy, in this case a single action of `get`. Many
different link:https://argo-cd.readthedocs.io/en/stable/operator-manual/rbac/#rbac-resources-and-actions[actions, window="_blank"]
are available. A wildcard of `*` can be used which indicates all actions.
5. Next is the specific Argo CD resource, this can be a wildcard like `*` for all resources or a named resource such as `{user}` in this case
indicating the `{user}` Project. For resources like Applications that are scoped to Projects a notation of
`<Project>/<Application>` can be used as shown in subsequent lines.
6. Finally whether we `allow` or `deny` the permission.

Once we have defined our role via policies we can then assign the policy to a group, this is indicated
by a `g` at the start of the line. For example, the line `g, teamX, proj:{user}:admin` indicates we
are assigning the project scoped role `admin` to the group `teamX`.

Note that what is considered a `group` for matching purposes is controlled by the `scope` that was
reviewed earlier. While `groups` is the most commonly set scope, having scopes like `email`
allows you to match roles to individual users. In a nutshell, when adding additional scopes, like `email`, these
are treated as groups by Argo CD for matching purposes.

As discussed, the ability to view this basic project has been granted but
not to modify or delete it. To confirm that, try deleting the Project:

[.console-input]
[source,sh,subs="attributes",role=execute]
----
argocd proj delete {user}
----

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
FATA[0000] rpc error: code = PermissionDenied desc = permission denied: projects, delete, user1, sub: user1-cli, iat: 2024-07-30T17:14:43Z
----

As expected we were denied permission to delete the Project. Again as a reminder the Argo RBAC is only used when you interact with
Argo CD via its UI or CLI. If you have permissions on the `AppProject` kind in the Argo CD namespace you could delete the resource
with `oc delete appproject {user} -n gitops` and the Argo CD RBAC would never be checked,

This inability to let users interact with resources in the Argo CD namespace is a challenge when you want to give users the ability to
declaratively manage Applications instead of managing them imperatively via the UI or CLI, fortunately
Argo CD has you covered as we will see in the next module.
